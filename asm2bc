#!/usr/bin/env ruby -w
=begin
Copyright (c) 2013 Noel Raymond Cower.

This file is part of Rusalka VM.

Rusalka VM is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Rusalka VM is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Rusalka VM.  If not, see <http://www.gnu.org/licenses/>.
=end


require './lexer.rb'
require 'digest'

module Op
  RegisterArg = Struct.new(:argtype, :kind)
  OPS = {}
  OP_PACKS = {}

  module Loading

    def self.reg(type, kind) ; RegisterArg.new(type, kind) ; end
    def self.method_missing(name, *args) ; name ; end
    def self.const_missing(name) ; name ; end

    define_singleton_method(:VM_LICENSE) { |*args| }

    define_singleton_method(:INSTRUCTION) {
      |codename, asm_name, code, num_args, *args|
      ::Op.const_set(codename, code)
      ::Op::OPS[asm_name.downcase] = ::Op.const_get(codename)
      ::Op::OP_PACKS[asm_name.downcase] = args.map { |arg|
        case arg
        when RegisterArg then 'l'
        when :f32 then 'L'
        when :ui32 then 'L'
        when :i32 then 'l'
        when :value then 'L'
        else raise 'invalid argument type'
        end
      }.join('')
    }

    self.module_eval(File.open('vm_instructions.h') { |io| io.read }, 'vm_instructions.h')
  end
end

StringLit = Struct.new(:kind, :value)
Instruction = Struct.new(:name, :args)
class Label
  attr_reader :name, :mangled, :kind
  def initialize(context, name, kind)
    @name = name
    @kind = case kind
            when :dot, :exported then :exported
            when :at, :local then :local
            when :caret, :imported then :imported
            else raise "invalid label kind: #{kind}"
            end
    @mangled = mangle_sym(context, name, @kind)
  end

  def to_s
    inspect
  end

  def inspect
    "#{name}:#{mangled}<#{kind}>"
  end

  def hash
    mangled.hash
  end

  def eql?(other)
    other.kind_of?(Label) && mangled == other.mangled
  end
end


labels = {}
instructions = []

def pack_uint(i)
  [i].pack('L')
end

def pack_int(i)
  [i].pack('l')
end

def file_contents(file)
  File.open(file, 'r') { |io| io.read }
end

def pack_float(num)
  [num.to_f].pack('f').unpack('L')[0]
end

def read_instructions(tokens)
end

def lex(source)
  lexer = Lexer.new
  lexer.skip_comments = true
  lexer.skip_newlines = false
  lexer.run(source).tokens
end

def mangle_sym(context, sym, kind)
  case kind
  when :local, :at then :"#{context}__#{sym}__"
  when :exported, :dot then :"__#{sym}__"
  when :imported, :caret then sym
  else raise "invalid symbol kind"
  end
end

FIRST_ARGUMENT_REGISTER = 4

POS_INT_LITS = [:integer_lit, :integer_exp_lit, :hex_lit, :bin_lit]
INT_LITS = [:minus] | POS_INT_LITS
FLOAT_LITS = [:float_lit, :float_exp_lit, :minus]
NUMERIC_LITS = FLOAT_LITS | INT_LITS
BITFIELD_LIT_TOKENS = [:bracket_open] | POS_INT_LITS
REGISTER_LITS = [:id, :dollar] | POS_INT_LITS
LABEL_LITS = [:caret, :dot, :at]
STRING_LITS = [:double_string_lit, :single_string_lit, :tilde]


ARG_TOKENS =
  INT_LITS |
  FLOAT_LITS |
  BITFIELD_LIT_TOKENS |
  REGISTER_LITS |
  LABEL_LITS |
  STRING_LITS

def parse_argument(context, reader, only_tokens: ARG_TOKENS, negated_lits: NUMERIC_LITS, fail: "invalid argument", distance: nil)
  reader.read_token(kinds: only_tokens, fail: fail, distance: distance) { |t|
    case t.kind
    when :dot, :at, :caret
      reader.read_token(:id, fail: "expected label name", distance: {columns: 0}) { |l|
        Label.new(context, l.value.to_sym, t.kind)
      }

    when :bracket_open
      bits = []

      until reader.read_token(:bracket_close, fail: false) { |*| true } do
        bitnum = parse_argument(context, reader, only_tokens: REGISTER_LITS, fail: "invalid bitset argument")
        raise "invalid bitnum: #{bitnum} (#{bitnum.class})" unless bitnum.kind_of?(Fixnum)
        warn "redundant bitnum already specified: #{bitnum}" if bits[bitnum]
        bits << bitnum
      end

      bits.reduce(0x0) { |a, e|
        raise "invalid bit: #{e}" if e > 31 || e < 0
        a | (0x1 << e)
      }

    when :id
      case t.value.to_sym
      when :ip then 0
      when :ebp then 1
      when :esp then 2
      when :rp then 3
      when :argv
        reader.read_token(:bracket_open, distance: {columns: 0}, fail: "expected opening bracket")
        reg = parse_argument(context, reader, only_tokens: POS_INT_LITS, fail: "expected argument register number")
        reader.read_token(:bracket_close, fail: "expected closing bracket")
        reg + FIRST_ARGUMENT_REGISTER
      else raise "invalid register name #{t.value}"
      end

    when :dollar
      FIRST_ARGUMENT_REGISTER + parse_argument(context, reader, only_tokens: POS_INT_LITS, distance: {columns: 0})

    when :integer_lit, :integer_exp_lit, :bin_lit, :hex_lit
      t.to_i

    when :float_lit, :float_exp_lit
      t.to_f

    when :double_string_lit, :single_string_lit
      StringLit.new(:literal, t.value)

    when :tilde
      reader.read_token(:id, fail: "expected data identifier", distance: {columns: 0}) { |id|
        StringLit.new(:reference, id.value.to_sym)
      }

    when :minus
      -parse_argument(context, reader, only_tokens: negated_lits, negated_lits: negated_lits, distance: {columns: 0})
    end
  }
end

def parse(context, tokens, instructions, labels, data_blocks, string_mappings)
  reader = TokenReader.new(tokens)
  reader.skip_whitespace_on_read = false

  until reader.eof?
    case
    when reader.read_token(:id, value: 'defdata', fail: false) { |defstring|
      reader.read_token(:id, fail: "expected identifier") { |string_ident|
        reader.read_token(kinds: [:double_string_lit, :single_string_lit], fail: "expected string literal") { |string_lit|
          data_blocks[string_lit.value] = (block_id = data_blocks.length + 1)
          string_mappings[string_ident.value.to_sym] = block_id
          true
        }
      }
    }

    when reader.read_token(kinds: [:dot, :at], fail: false) { |li|
      reader.read_token(:id, fail: "expected label name") { |t|
        label = Label.new(context, t.value.to_sym, li.kind)
        raise "label #{li.value}#{label.name} already defined" if labels.include?(label)
        labels[label] = instructions.length
        # puts "label: #{label.mangled}@#{instructions.length}"
        true
      }
    }

    when reader.read_token(:id, fail: false) { |instr_token|
      instr_name = instr_token.value.to_sym
      # puts "parsing #{instr_name}"
      if Op::OPS.include?(instr_name)
        args = Op::OP_PACKS[instr_name].length.times.map { parse_argument(context, reader) }
        instructions << Instruction.new(instr_name, args)
        true
      else
        raise "#{instr_token.position} unrecognized instruction: #{instr_name}"
      end
    }
    end

    reader.read_token(:newline, fail: "expected newline") if !reader.eof?
  end
end

hasher = Digest::SHA256.new

string_mappings = {}
data_blocks = {}

ARGV[1..-1].each { |file|
  contents = file_contents(file)
  tokens = lex(contents)
  ctx_digest = Digest.hexencode(hasher.digest(contents))
  parse(ctx_digest, tokens, instructions, labels, data_blocks, string_mappings)
}

exported_label = -1
instructions.each { |instr|
  instr.args = instr.args.map { |a|
    case a
    when Label
      if labels.include?(a)
        labels[a]
      elsif a.kind == :imported
        loc = exported_label
        exported_label -= 1
        labels[a] = loc
        loc
      else
        raise "No matching label for #{a}"
      end
    when StringLit
      case a.kind
      when :literal
        if data_blocks.include?(a.value)
          data_blocks[a.value]
        else
          block_id = data_blocks.length + 1
          data_blocks[a.value] = block_id
          block_id
        end
      when :reference
        string_mappings[a.value]
      end
    when Float then pack_float(a)
    else a
    end
  }
}

def write_label_table(io, head, table)
  return if table.nil?
  io.write head
  data = ""
  data << pack_uint(table.length)
  table.each { |k, v|
    data << pack_int(v)
    data << pack_uint(k.name.length)
    data << k.name.to_s
  }
  io.write pack_uint(data.bytesize)
  io.write data
end

def write_data_table(io, head, table)
  io.write head
  data = ""
  data << pack_uint(table.size)
  table.each { |block, id|
    data << [id, block.bytesize].pack('LL')
    data << block
  }
  io.write pack_uint(data.bytesize)
  io.write data
end

def write_code(io, instructions)
  io.write "CODE"
  data = pack_uint(instructions.length)
  instructions.each { |instr|
    data << [Op::OPS[instr.name]].pack('L')
    data << instr.args.pack(Op::OP_PACKS[instr.name])
  }

  io.write pack_uint(data.bytesize)
  io.write data
end

def write_data(io, labels, instructions, data_blocks)
  lgroups = labels.group_by { |k, v| k.kind }
  exports = lgroups[:exported]
  imports = lgroups[:imported]

  write_data_table(io, "DATA", data_blocks)
  write_label_table(io, "IMPT", imports)
  write_label_table(io, "EXPT", exports)

  write_code(io, instructions)
end

if (ARGV[0] == '-')
  write_data(STDOUT, labels, instructions, data_blocks)
else
  File.open(ARGV[0], 'w') { |io|
    write_data(io, labels, instructions, data_blocks)
  }
end
