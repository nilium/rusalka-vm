#!/usr/bin/env ruby
###############################################################################
#  Copyright (c) 2013 Noel Raymond Cower.                                     #
#                                                                             #
#  This file is part of Rusalka VM.                                           #
#                                                                             #
#  Rusalka VM is free software: you can redistribute it and/or modify         #
#  it under the terms of the GNU General Public License as published by       #
#  the Free Software Foundation, either version 3 of the License, or          #
#  (at your option) any later version.                                        #
#                                                                             #
#  Rusalka VM is distributed in the hope that it will be useful,              #
#  but WITHOUT ANY WARRANTY; without even the implied warranty of             #
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              #
#  GNU General Public License for more details.                               #
#                                                                             #
#  You should have received a copy of the GNU General Public License          #
#  along with Rusalka VM.  If not, see <http://www.gnu.org/licenses/>.        #
###############################################################################


require './lexer.rb'
require 'digest'
require 'securerandom'
require 'set'


BYTECODE_VERSION = 8


###############################################################################
#  Parsing vm_instructions.h                                                  #
###############################################################################

module Op

  class << self
    attr_accessor :license
  end

  RegisterArg = Struct.new(:argtype, :kind)
  OPS = {}
  OP_ARGS = {}
  OP_NAMES = []
  OP_PACKS = {}
  OP_HAS_LITFLAG = {}

  module Loading

    def self.litflag ; :litflag ; end
    def self.method_missing(name, *args) ; name ; end
    def self.const_missing(name) ; name ; end

    define_singleton_method(:VM_LICENSE) do |*args|
      ::Op.license = args.join "\n"
      nil
    end

    define_singleton_method(:INSTRUCTION) do
      |codename, asm_name, code, num_args, *args|
      ::Op.const_set(codename, code)
      ::Op::OP_NAMES << asm_name.downcase.tap do |name|
          ::Op::OPS[name] = ::Op.const_get(codename)
          ::Op::OP_PACKS[name] = 'E' * args.length
          ::Op::OP_ARGS[name] = args
          ::Op::OP_HAS_LITFLAG[name] = args.include?(:litflag)
        end.to_s
    end

    self.module_eval(
      File.open('vm_instructions.h') { |io| io.read },
      'vm_instructions.h'
      )
  end
end


###############################################################################
#  File loading / lexing                                                      #
###############################################################################

def file_contents(file)
  File.open(file, 'r') { |io| io.read }
end


def lex(source)
  lexer = Lexer.new
  lexer.skip_comments = true
  lexer.skip_newlines = false
  lexer.run(source).tokens
end


FIRST_ARGUMENT_REGISTER = 4

POS_INT_LITS = [:integer_lit, :integer_exp_lit, :hex_lit, :bin_lit]
INT_LITS = [:minus] | POS_INT_LITS
FLOAT_LITS = [:float_lit, :float_exp_lit, :minus]
STRING_LITS = [:double_string_lit, :single_string_lit]


Unit = Struct.new(:name, :prefix)
Instruction = Struct.new(:name, :args)
DefDataStmt = Struct.new(:name, :string, :mangled)
RegisterRef = Struct.new(:index)
AnonDataStmt = Struct.new(:id, :prefix)
DataRef = Struct.new(:name, :lookup)
LabelRef = Struct.new(:label)
LabelStmt = Struct.new(:label)


class RegisterRef
  def to_i ; index ; end
  def to_f ; index.to_f ; end
end


class Label
  attr_reader :name, :mangled, :kind

  class << self
    alias_method :[], :new

    def mangle_sym(context, sym, kind)
      case kind
      when :local, :at then :"#{context}__#{sym}__"
      when :export, :dot then :"__#{sym}__"
      when :import, :caret then sym
      else raise "invalid symbol kind"
      end
    end
  end

  def kind_char
    case kind
    when :export then '.'
    when :import then '^'
    when :local then '@'
    end
  end

  def initialize(prefix, name, kind)
    if name.bytesize > 65535
      raise "Label names may not be greater than 65,535 characters in length"
    end

    @name = name
    @kind = case kind
            when :dot, :export then :export
            when :at, :local then :local
            when :caret, :import then :import
            else raise "invalid label kind: #{kind}"
            end
    @mangled = self.class.mangle_sym(prefix, name, @kind)
  end

  def to_s
    inspect
  end

  def inspect
    "#{name}:#{mangled}<#{kind}>"
  end

  def hash
    mangled.hash
  end

  def eql?(other)
    other.kind_of?(Label) && mangled == other.mangled
  end
end


###############################################################################
#  The Parser                                                                 #
###############################################################################

class Parser

  # The prefix is any prefix used for a specific file when mangling local
  # names. At the moment, it's a SHA256 hash of the file being parsed. Must
  # be assigned before calling run(...).
  attr_accessor :prefix
  attr_reader :instructions
  attr_reader :labels
  attr_reader :string_mappings
  attr_reader :data_mappings
  attr_reader :data

  # Returns a block selecting for the given kinds
  def select_kind(*kinds, &block)
    -> (obj, *args) do
      kinds.any? do |klass|
        obj.kind_of?(klass)
      end && (block.nil? || block[obj])
    end
  end

  def unique_uuid
    result =
      loop do
        generated = SecureRandom.uuid
        next if @uuids.include? generated
        break generated
      end.tap { |k| @uuids << k }

    "uuid_#{result.gsub('-', '_')}"
  end


  def initialize
    @uuids           = Set.new
    @data            = []
    @prefix          = nil
    @instructions    = []
    @labels          = {}
    @label_mappings  = {}
    @string_mappings = {}
    @data_mappings   = {}
    @import_count    = 0
  end

  # Looks up a reference and returns the value.
  def lookup(ref)
    case ref
    when RegisterRef
      ref.index
    when LabelRef
      # All non-import labels should have assigned instruction values by this
      # point.
      @label_mappings[ref.label.mangled] ||=
        case ref.label.kind
        when :import then -(@import_count += 1)
        else error "Unmatched labelref"
        end
    when DataRef then @string_mappings[ref.lookup]
    else ref
    end
  end


  #############################################################################
  #  Try-and-fail Reading                                                     #
  #############################################################################

  def mark
    @marks << @index
    self
  end

  def unmark
    @marks.pop
    self
  end

  def reset
    if @index == @marks.last
      @marks.pop
      return self
    end

    @input.rewind
    @current = nil
    @column = 0
    @line = 0
    @index = 0

    # If there's a better way of doing this, I haven't found it.
    reset_to = @marks.pop
    (0 ... reset_to).each { read } if reset_to && reset_to > 0
    self
  end

  # For testing sequences of tokens, wrap calls in maybe? to reset to the
  # starting token on failure. Returning a nil value from the block is failure,
  # otherwise it's considered success.
  #
  # If only testing for a single token's acceptance for a value, then an
  # enclosing `maybe? { ... }` isn't necessary, though won't hurt.
  def maybe?
    raise "No block given" unless block_given?
    mark
    yield.tap do |result|
      if !result.nil?
        unmark
      else
        reset
      end
    end
  end


  #############################################################################
  #  Parsed Types                                                             #
  #############################################################################

  # $INTEGER
  def arg_num
    maybe? do
      accept(:dollar) && accept(:integer_lit, distance: 0) do |tok|
        RegisterRef[FIRST_ARGUMENT_REGISTER + tok.to_i]
      end
    end
  end

  # %INTEGER
  def register
    maybe? do
      accept(:percent) && accept(:integer_lit, distance: 0) do |tok|
        RegisterRef[tok.to_i]
      end
    end || arg_num
  end

  # String literals
  def string
    accept(STRING_LITS) do |tok|
      data = tok.value
      is_dupe = @data_mappings.include?(data)
      id = @data_mappings[data] ||= @data_mappings.length + 1
      stmt = AnonDataStmt[id, :"__data_#{unique_uuid}"]
      @string_mappings[stmt] = id
      unless is_dupe
        defstmt = DefDataStmt[stmt.prefix, data, mangle_data_name(stmt.prefix)]
        unit_idx = @data.index { |obj| obj.kind_of?(Unit) && obj.prefix == @prefix }
        @data.insert(unit_idx + 1, defstmt)
      end
      DataRef[stmt, stmt]
    end
  end

  # Number literals
  def number(distance: nil)
    accept(FLOAT_LITS, &:to_f) || accept(INT_LITS, &:to_i)
  end

  # [ NUMERICS* ]
  def bitset
    maybe? do
      break unless accept :bracket_open

      bits = 0
      until accept :bracket_close
        bitnum = (bitwise_not(:numeric) || negative(:numeric) || numeric || register || error).to_i
        warn "Repeating bitnums in bitset" if bits[bitnum] != 0
        bits |= 1 << bitnum
      end

      bits
    end
  end

  # ~ID
  def data_ref
    maybe? do
      accept(:tilde) && accept(:id, distance: 0) do |tok|
        name = tok.value.to_sym
        DataRef[name, mangle_data_name(name)]
      end
    end
  end

  # Negates the next value read by sym
  def negative(sym = :value)
    accept(:minus) do |tok|
      (peek.position.column == tok.position.column + 1 && -self.send(sym)) || error
    end
  end

  # Performs a 32-bit bitwise not on the next value read by sym
  def bitwise_not(sym = :value)
    accept(:tilde) do |tok|
      (peek.position.column == tok.position.column + 1 && ((~self.send(sym)) & 0xFFFFFFFF)) || error
    end
  end

  # Numerics
  def numeric
    named_register || number || bitset
  end

  # ^NAME
  def import
    maybe? do
      accept(:caret) && accept(:id, distance: 0) do |tok|
        LabelRef[Label[@prefix, tok.value, :import]].tap do |ref|
          @labels[ref.label.name] = ref.label
        end
      end
    end
  end

  # .NAME
  # @NAME
  def label_name
    maybe? do
      kind = accept(:dot, :at) do |k|
        case k.kind
        when :dot then :export
        when :at then :local
        end
      end

      break unless kind
      name = accept(:id, distance: 0, &:value)

      yield kind, name if kind && name
    end
  end

  # label_name
  def label_ref
    label_name { |kind, name| LabelRef[Label[@prefix, name, kind]] }
  end

  # label_name TERM
  def label
    label_name do |kind, name|
      break unless accept(:colon, distance: 0)
      LabelStmt[Label[@prefix, name, kind]].tap do |stmt|
        if @label_mappings.include?(stmt.label.mangled)
          warn "Duplicate label: #{stmt.label.name}"
        end

        @label_mappings[stmt.label.mangled] = @instructions.length
        @labels[stmt.label.mangled] = stmt.label
      end
    end
  end

  # ip
  # ebp
  # esp
  # rp
  def named_register
    case accept(:id, content: ['ip', 'ebp', 'esp', 'rp'], &:value)
    when 'ip'  then RegisterRef[0]
    when 'ebp' then RegisterRef[1]
    when 'esp' then RegisterRef[2]
    when 'rp'  then RegisterRef[3]
    end
  end

  # Any valid argument to an instruction
  def value
    data_ref ||
    negative ||
    bitwise_not ||
    register ||
    label_ref ||
    import ||
    numeric ||
    string ||
    error
  end

  # Reads a line
  def line
    while accept(:newline, :semicolon)
    end
    label || statement || error unless eof?
  end

  # EOF | "\n" | ";"
  def terminator
    (eof? || accept(:newline, :semicolon))
  end

  def mangle_data_name(name)
    :"#{@prefix}__#{name}"
  end

  # Data statements
  # defdata NAME STRING TERM
  def defdata
    maybe? do
      name = accept(:id, content: 'defdata') && accept(:id, &:value)
      break unless name
      mangled = mangle_data_name(name)
      accept(STRING_LITS) do |t|
        data = t.value
        stmt = DefDataStmt[name, data, mangle_data_name(name)] if terminator
        break unless stmt

        if @string_mappings.include?(mangled)
          warn "Data with name '#{mangled}' already defined"
        end

        @string_mappings[mangled] =
          (@data_mappings[data] ||= @data_mappings.length + 1)

        stmt
      end
    end
  end

  # Instruction and data statements
  def statement
    defdata || instruction
  end

  # OPNAME VALUE* TERM
  def instruction
    maybe? do
      name = accept(:id, content: Op::OP_NAMES, &:value)
      break unless name
      name = name.to_sym
      optional_flag = Op::OP_ARGS[name].last == :litflag
      num_args = Op::OP_PACKS[name].length - (optional_flag ? 1 : 0)
      args = Array.new(num_args) { value }

      done = false
      if optional_flag
        if !(done = terminator)
          args << value
        else
          opargs = Op::OP_ARGS[name]
          offset = opargs.first == :output ? 1 : 0
          args << args.each_with_index.select do |arg, index|
            opargs[index] == :input
          end.reduce(0) do |bits, packet; arg, index|
            arg, index = packet
            bits | (arg.kind_of?(RegisterRef) ? 0 : 1 << (index - offset))
          end
        end
      end

      Instruction[name, args].tap { |k| @instructions << k } if done || terminator
    end
  end


  #############################################################################
  #  Warnings / Errors                                                        #
  #############################################################################

  def error(*msg)
    $stderr.puts "Error when trying to read token: #{msg.join ' '}"
    $stderr.puts peek.inspect
    raise RuntimeError
  end

  def warn(*msgs)
    Kernel.warn(*msgs.map { |k| "[#{@line}:#{@column}] #{k}" })
  end


  #############################################################################
  #  Parser Execution                                                         #
  #############################################################################

  def run(input, filename = 'anonymous')
    @prefix = unique_uuid if @prefix.nil? || @prefix.empty?
    @prefix = "_#{@prefix}" if "0123456789".include?(@prefix[0])
    @data << Unit[filename, @prefix]
    @marks = []
    @index = 0
    @input = input
    @current = nil
    @line = 0
    @column = 0
    __run__
  ensure
    @prefix = nil
    @input = nil # don't retain the enumerator
  end

  def __run__
    until eof?
      data = line
      break if eof?
      error unless data
      @data << data
    end
  end


  #############################################################################
  #  Parser Input                                                             #
  #############################################################################

  def peek
    @input.peek
  rescue StopIteration
    nil
  end

  def read
    if @current
      @line = @current.position.line + @current.value.count("\n")
      @column =
        if @current.position.line == @line
          @current.position.column + @current.value.length
        else
          @current.value.length - @current.value.rindex("\n")
        end
    end
    @current = @input.next
    @index += 1
    @current
  rescue StopIteration
    @current = nil
    nil
  end

  def eof?
    peek.nil?
  end

  def accept(*tokens, content: nil, distance: nil)
    tok = peek
    tokens = tokens.flatten
    result =
      case
      when tok.nil? then nil
      when !tokens.empty? && !tokens.include?(tok.kind) then nil
      when content.kind_of?(Regexp) && content.match(tok.value).nil? then nil
      when content.kind_of?(String) && content != tok.value then nil
      when content.kind_of?(Array) && !content.include?(tok.value) then nil
      when case distance
           when Numeric # columns
           when Hash
             lines, columns = [distance[:lines] || 0, distance[:columns] || 0]
             @line - tok.position.line > lines || @column - tok.position.column > columns
           when Array
             lines, columns = distance
             @line - tok.position.line > lines || @column - tok.position.column > columns
           else false
           end
        nil
      else read
      end
    if result && block_given?
      yield result
    else
      result
    end
  end


  #############################################################################
  #  Parser Output                                                            #
  #############################################################################

  def data_blocks
    mapped =
      @data_mappings.map do |data, id|
        if data.kind_of? Array
          data = data.last
        end

        [data, id]
      end.sort_by!(&:last).map! do |data, id|
        "#{[id, data.bytesize].pack('l<s<')}#{data}"
      end.join

    "#{[@data_mappings.length].pack('l<')}#{mapped}"
  end

  def filtered_labels(*kinds)
    @labels.to_a.keep_if { |n, l| kinds.include? l.kind }
  end

  def imports_data
    label_data filtered_labels :import
  end

  def exports_data
    label_data filtered_labels :export
  end

  def label_data(labels)
    data =
      labels.map do |name, label|
        namedata = name.to_s.encode(Encoding::UTF_8)

        if namedata.bytesize > 65535
          raise "Label may not exceed 65,535 characters in length"
        end

        packdata = [lookup(LabelRef[label]), namedata.bytesize].pack('l<s<')
        "#{packdata}#{namedata}"
      end.join

    "#{[labels.length].pack('l<')}#{data}"
  end

  def instruction_data
    data =
      @instructions.map do |instr|
        [Op::OPS[instr.name], *instr.args.map { |arg| lookup(arg).to_f }].pack('s<E*')
      end.join

    "#{[@instructions.length].pack('l<')}#{data}"
  end

  RELOCATION_TABLE_MAP = -> (arg, index) { index }

  def relocation_table(&block)
    raise "No block given" if block.nil?
    data =
      @instructions.each_with_index.map do |instr, index|
        if instr.args.any?(&block)
          refs = instr.args.each_with_index.select { |obj, index| block[obj] }.map!(&:last)
          [index, refs.length, *refs].pack('l<*')
        else
          nil
        end
      end.delete_if(&:nil?)

    "#{[data.length].pack('l<')}#{data.join}"
  end

  def label_relocation_table
    relocation_table { |arg| arg.kind_of? LabelRef }
  end

  def data_relocation_table
    relocation_table { |arg| arg.kind_of? DataRef }
  end

end # Parser


Chunk = Struct.new(:name, :data)


def chunk_size(data)
  # sizeof(name) + sizeof(chunk size) + sizeof(data)
  8 + data.bytesize
end


def write_chunk(name, data, io)
  name = name.to_s
  raise "Chunk name must be exactly 4 bytes in size" unless name.bytesize == 4

  io.write(name)
  io.write([8 + data.bytesize].pack('l<'))
  io.write(data)
end


def write_data(parser, io)
  version_data = [BYTECODE_VERSION].pack('l<')

  chunks = [
    Chunk[:VERS, version_data],
    Chunk[:OFFS, 0],
    Chunk[:LREL, parser.label_relocation_table],
    Chunk[:DREL, parser.data_relocation_table],
    Chunk[:DATA, parser.data_blocks],
    Chunk[:IMPT, parser.imports_data],
    Chunk[:EXPT, parser.exports_data],
    Chunk[:INST, parser.instruction_data],
  ]

  # [chunk count] + [[label, offset], ...]
  chunks[1].data = ([0] + Array.new(chunks.length, [0, 0])).flatten.pack('l<*')

  relative_off = 0
  offsets = chunks.map do |chunk|
    size = chunk_size(chunk.data)
    data = "#{chunk.name}#{[relative_off].pack('l<')}"
    relative_off += size
    data
  end

  chunks[1].data = "#{[offsets.length].pack('l<')}#{offsets.join}"

  chunks.each do |chunk|
    write_chunk(chunk.name, chunk.data, io)
  end

  nil
end


flags = Struct.new(:print_instrs).new

loop {
  case ARGV.first
  when '--print-instrs' then flags.print_instrs = true
  else break
  end
  ARGV.shift
}

# Print help text if the minimum number of arguments aren't provided.
if ARGV.length < 2
  puts <<-EOS.gsub(/^    /, '')
    asm2bc output input...
     - output may be any file path, or '-' to write to the standard output.
     - input must be one or more named files.

    Options:
      --print-instrs
        Writes the instructions asm2bc has read to the standard error. This
        can be used to debug asm2bc if its output seems to be incorrect --
        handy for bug testing.

    -----------------------------------------------------------------------

    asm2bc (Rusalka VM) Copyright (C) 2014 Noel Cower

    This program comes with ABSOLUTELY NO WARRANTY. This program is free
    software: you can redistribute it and/or modify it under the terms of
    the GNU General Public License as published by the Free Software
    Foundation, either version 3 of the License, or (at your option) any
    later version.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
  EOS

  exit 1
end

hasher = Digest::SHA256.new
parser = Parser.new
output_file = ARGV.shift

ARGV.each do |file|
  unit_name     = (file == '-') ? 'anonymous' : file
  contents      = (file == '-') ? $stdin.read() : file_contents(file)
  tokens        = lex(contents)
  unit_digest   = Digest.hexencode(hasher.digest(contents))
  # parser.prefix = unit_digest
  parser.run(tokens.each, file)
end

def mul_of(x, n)
  ([(x.to_f / n).ceil, 1].max * n)
end

if flags.print_instrs

  max_arg_columns = []

  max_name_len = Op::OPS.map { |k, v| k.length }.max + 1
  args = parser.instructions.map { |i|
    i.args.each_with_index.map { |a, j|
      a =
        if Op::OP_ARGS[i.name][j] == :litflag && a.kind_of?(Numeric)
          "0b#{parser.lookup(a).to_i.to_s(2)}"
        elsif a.kind_of?(LabelRef)
          "/* #{a.label.kind_char}#{a.label.name} => */ #{parser.lookup(a).to_s}"
        elsif a.kind_of?(DataRef)
          "/* ~#{
            case a.name
            when AnonDataStmt then a.name.prefix
            else a.name
            end
          } => */ #{parser.lookup(a).inspect.to_s}"
        elsif a.kind_of?(RegisterRef)
          case a.index
          when 0 then 'ip'
          when 1 then 'ebp'
          when 2 then 'esp'
          when 3 then 'rp'
          else "%#{a.index}"
          end
        else
          parser.lookup(a).to_s
        end

      max_arg_columns[j] = max_arg_columns.fetch(j, []) << a.length

      a
    }
  }
  max_arg_columns.map! { |k| mul_of(k.max, 4) }
  args.each { |ap| ap.map!.each_with_index { |s, j| s.rjust(max_arg_columns[j]) } }
  max_line_no_length = ([parser.instructions.length.to_s.length / 4, 3].max) * 4
  instr_index = 0
  parser.data.each_with_index do |datum, index|
    case datum
    when Unit
      $stderr.write "\n\n" if index != 0
      $stderr.puts "/#{'*' * 99}"
      $stderr.puts "    Unit: #{datum.name} (#{datum.prefix})"
      $stderr.puts "#{'*' * 99}/\n\n"
    when DefDataStmt
      stmt = datum
      $stderr.puts "// Data: #{stmt.mangled}"
      $stderr.puts "defdata  #{stmt.name}  #{stmt.string.inspect}"
    when Instruction
      instr = datum
      $stderr.write "    #{"/* #{instr_index} */".ljust(max_line_no_length)}"
      $stderr.write "#{instr.name.to_s.ljust(max_name_len)}"
      $stderr.write " #{args[instr_index].join '  '}" unless args[instr_index].empty?
      $stderr.write "\n"
      instr_index += 1
    when LabelStmt
      $stderr.write "\n" if index != 0
      label = datum.label
      $stderr.puts "// #{label.mangled}"
      $stderr.write case label.kind
                    when :export then '.'
                    when :local then '@'
                    when :import then '^' # never occurs
                    end
      $stderr.write label.name
      $stderr.write ":\n"
    else
    end
  end
end

case output_file
when '-' then write_data(parser, $stdout)
else File.open(output_file, 'w') { |io| write_data(parser, io) }
end
